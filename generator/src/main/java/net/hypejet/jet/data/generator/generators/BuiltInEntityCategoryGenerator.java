package net.hypejet.jet.data.generator.generators;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import net.hypejet.jet.data.entity.category.EntityCategory;
import net.hypejet.jet.data.generator.ConstantGenerator;
import net.hypejet.jet.data.generator.Generator;
import net.hypejet.jet.data.generator.util.CodeBlocks;
import net.hypejet.jet.data.generator.util.JavaDocBuilder;
import net.minecraft.world.entity.MobCategory;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.slf4j.Logger;

import javax.lang.model.element.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Represents a {@linkplain ConstantGenerator constant generator}, which generates {@linkplain EntityCategory entity
 * categories} using data defined in an {@linkplain MobCategory mob category enum}.
 *
 * @since 1.0
 * @author Codestech
 * @see EntityCategory
 * @see MobCategory
 * @see Generator
 */
public final class BuiltInEntityCategoryGenerator extends ConstantGenerator {

    private static final String PACKAGE = "net.hypejet.jet.data.entity.category";
    private static final String CLASS = "BuiltInEntityCategories";

    static final ClassName CLASS_NAME = ClassName.get(PACKAGE, CLASS);

    private static final Class<?> ENTITY_CATEGORY_CLASS = EntityCategory.class;

    /**
     * Constructs the {@linkplain BuiltInEntityCategoryGenerator vanilla entity category generator}.
     *
     * @since 1.0
     */
    public BuiltInEntityCategoryGenerator() {
        super(PACKAGE, CLASS_NAME, ENTITY_CATEGORY_CLASS,
                JavaDocBuilder.builder()
                        .line("Represents a holder of built-in Minecraft entity categories.")
                        .paragraph("Code autogenerated, do not edit!")
                        .emptyLine()
                        .since("1.0")
                        .see(ENTITY_CATEGORY_CLASS)
                        .build(),
                JavaDocBuilder.builder()
                        .line("Gets all built-in entity categories.")
                        .emptyLine()
                        .returns("the categories")
                        .since("1.0")
                        .see(ENTITY_CATEGORY_CLASS)
                        .build());
    }

    @Override
    public @NonNull Collection<FieldSpec> generateFields(@NonNull Logger logger) {
        List<FieldSpec> entityCategoriesFieldSpecs = new ArrayList<>();
        ClassName entityCategoryImplClass = ClassName.get(PACKAGE, "EntityCategoryImpl");

        for (MobCategory category : MobCategory.values()) {
            int maxInstancesPerChunk = category.getMaxInstancesPerChunk();

            boolean friendly = category.isFriendly();
            boolean persistent = category.isPersistent();

            int noDespawnDistance = category.getNoDespawnDistance();
            int despawnDistance = category.getDespawnDistance();

            String name = category.getName();

            entityCategoriesFieldSpecs.add(FieldSpec.builder(ENTITY_CATEGORY_CLASS, constantName(category))
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer(CodeBlocks.constructor(entityCategoryImplClass, maxInstancesPerChunk, friendly,
                            persistent, noDespawnDistance, despawnDistance, CodeBlocks.string(name)))
                    .build());
        }

        return List.copyOf(entityCategoriesFieldSpecs);
    }

    /**
     * Generates a name of a constant that should define a generated {@linkplain EntityCategory entity category}
     * using a {@linkplain MobCategory mob category}.
     *
     * @param category the mob category
     * @return the name
     * @since 1.0
     */
    static @NonNull String constantName(@NonNull MobCategory category) {
        return category.getName().toUpperCase();
    }
}